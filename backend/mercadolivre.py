import os
import httpx
import base64
import hashlib
import secrets
from datetime import datetime, timedelta
from typing import Optional
from urllib.parse import urlencode

ML_API_URL = "https://api.mercadolibre.com"
ML_CLIENT_ID = os.getenv("ML_CLIENT_ID")
ML_CLIENT_SECRET = os.getenv("ML_CLIENT_SECRET")
ML_REDIRECT_URI = os.getenv("ML_REDIRECT_URI", "https://vigia-meli.vercel.app/auth/mercadolivre/callback")

# Armazenamento simples do token (em produ√ß√£o, usar Redis ou banco)
ml_tokens = {}
pkce_store = {}

class MLTokenManager:
    @staticmethod
    def store_token(user_id: int, token_data: dict):
        """Armazena o token OAuth do usu√°rio"""
        expires_in = token_data.get("expires_in", 3600)
        expires_at = datetime.now() + timedelta(seconds=expires_in)
        
        ml_tokens[user_id] = {
            "access_token": token_data["access_token"],
            "refresh_token": token_data.get("refresh_token"),
            "expires_at": expires_at,
            "user_id": token_data.get("user_id"),
            "scope": token_data.get("scope")
        }
        
        print(f"üîê Token armazenado para user {user_id}, expira em {expires_at}")

async def buscar_produto_ml(ml_id: str, user_id: int = None):
    """
    Busca produto espec√≠fico conforme documenta√ß√£o oficial ML
    Suporta busca p√∫blica e autenticada
    """
    url = f"{ML_API_URL}/items/{ml_id}"
    
    print(f"üîç Buscando produto {ml_id}, user_id={user_id}")
    
    if user_id:
        # Tentar busca autenticada primeiro
        token = MLTokenManager.get_token(user_id)
        if token:
            print(f"üîê Tentando busca autenticada")
            try:
                async with httpx.AsyncClient() as client:
                    headers = {"Authorization": f"Bearer {token}"}
                    resp = await client.get(url, headers=headers, timeout=10.0)
                    if resp.status_code == 200:
                        data = resp.json()
                        print(f"‚úÖ Busca autenticada bem-sucedida")
                        return {
                            "nome": data.get("title"),
                            "preco": data.get("price"),
                            "estoque": data.get("available_quantity"),
                            "url": data.get("permalink"),
                            "thumbnail": data.get("thumbnail"),
                            "vendedor_id": data.get("seller_id"),
                        }
                    print(f"‚ö†Ô∏è Busca autenticada falhou: {resp.status_code}")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro na busca autenticada: {e}")
    
    # Busca p√∫blica como fallback
    print(f"üåê Fazendo busca p√∫blica do produto")
    try:
        import requests
        # Busca p√∫blica sem headers
        resp = requests.get(url)
        print(f"üìä Status busca p√∫blica: {resp.status_code}")
        
        if resp.status_code == 200:
            data = resp.json()
            print(f"‚úÖ Busca p√∫blica bem-sucedida")
            return {
                "nome": data.get("title"),
                "preco": data.get("price"),
                "estoque": data.get("available_quantity"),
                "url": data.get("permalink"),
                "thumbnail": data.get("thumbnail"),
                "vendedor_id": data.get("seller_id"),
            }
        else:
            print(f"‚ùå Busca p√∫blica falhou: {resp.status_code}")
            return None
    except Exception as e:
        print(f"‚ùå Erro na busca p√∫blica: {e}")
        return None
    
    @staticmethod
    def get_token(user_id: int) -> Optional[str]:
        """Recupera o token v√°lido do usu√°rio"""
        if user_id not in ml_tokens:
            return None
        
        token_info = ml_tokens[user_id]
        
        # Verificar se o token expirou
        if datetime.now() >= token_info["expires_at"]:
            # Token expirado, tentar renovar
            return MLTokenManager.refresh_token(user_id)
        
        return token_info["access_token"]
    
    @staticmethod
    def refresh_token(user_id: int) -> Optional[str]:
        """Renova o token OAuth usando refresh_token"""
        if user_id not in ml_tokens:
            return None
        
        token_info = ml_tokens[user_id]
        refresh_token = token_info.get("refresh_token")
        
        if not refresh_token:
            return None
        
        # TODO: Implementar refresh do token
        # Por enquanto, remover token expirado
        del ml_tokens[user_id]
        return None
    
    @staticmethod
    def revoke_token(user_id: int):
        """Remove o token do usu√°rio"""
        if user_id in ml_tokens:
            del ml_tokens[user_id]

def generate_pkce_pair():
    """Gera code_verifier e code_challenge para PKCE"""
    # Gerar code_verifier (43-128 caracteres)
    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32)).decode('utf-8').rstrip('=')
    
    # Gerar code_challenge (SHA256 do verifier)
    digest = hashlib.sha256(code_verifier.encode('utf-8')).digest()
    code_challenge = base64.urlsafe_b64encode(digest).decode('utf-8').rstrip('=')
    
    return code_verifier, code_challenge

def get_ml_auth_url(state: str = None) -> str:
    """Gera URL de autoriza√ß√£o OAuth do Mercado Livre com PKCE"""
    
    # Gerar PKCE
    code_verifier, code_challenge = generate_pkce_pair()
    
    # Usar user_id do state para salvar o verifier
    if state and state.startswith('user_'):
        user_id = state.split('_')[1]
        pkce_store[user_id] = code_verifier
        print(f"üîê PKCE gerado para user {user_id}: verifier={code_verifier[:10]}..., challenge={code_challenge[:10]}...")
    
    # Par√¢metros OAuth com PKCE
    params = {
        "response_type": "code",
        "client_id": ML_CLIENT_ID,
        "redirect_uri": ML_REDIRECT_URI,
        "scope": "read write offline_access",
        "code_challenge": code_challenge,
        "code_challenge_method": "S256"
    }
    
    if state:
        params["state"] = state
    
    auth_url = f"https://auth.mercadolivre.com.br/authorization?{urlencode(params)}"
    print(f"üîó URL de autoriza√ß√£o gerada: {auth_url[:100]}...")
    
    return auth_url

async def exchange_code_for_token(code: str, state: str = None) -> dict:
    """Troca o c√≥digo OAuth por token de acesso com PKCE"""
    token_url = f"{ML_API_URL}/oauth/token"
    
    # Recuperar code_verifier do state
    code_verifier = None
    if state and state.startswith('user_'):
        user_id = state.split('_')[1]
        code_verifier = pkce_store.get(user_id)
        print(f"üîê Recuperando verifier para user {user_id}: {code_verifier[:10] if code_verifier else 'N√ÉO ENCONTRADO'}...")
        
        # Limpar o verifier ap√≥s uso
        if code_verifier:
            del pkce_store[user_id]
    
    if not code_verifier:
        print("‚ùå code_verifier n√£o encontrado!")
        raise Exception("code_verifier n√£o encontrado. Tente autorizar novamente.")
    
    data = {
        "grant_type": "authorization_code",
        "client_id": ML_CLIENT_ID,
        "client_secret": ML_CLIENT_SECRET,
        "code": code,
        "redirect_uri": ML_REDIRECT_URI,
        "code_verifier": code_verifier  # PKCE obrigat√≥rio
    }
    
    print(f"üîÑ Trocando c√≥digo por token...")
    print(f"üìã Dados: grant_type={data['grant_type']}, client_id={data['client_id'][:10]}..., code={code[:10]}..., verifier={code_verifier[:10]}...")
    
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(token_url, data=data, timeout=30.0)
            
            print(f"üì° Response status: {response.status_code}")
            
            if response.status_code == 200:
                token_data = response.json()
                print(f"‚úÖ Token obtido com sucesso: {list(token_data.keys())}")
                return token_data
            else:
                error_text = response.text
                print(f"‚ùå Erro {response.status_code}: {error_text}")
                raise Exception(f"Erro ao obter token: {response.status_code} - {error_text}")
                
        except httpx.TimeoutException:
            print("‚ùå Timeout na requisi√ß√£o")
            raise Exception("Timeout na comunica√ß√£o com Mercado Livre")
        except Exception as e:
            print(f"‚ùå Erro na requisi√ß√£o: {e}")
            raise

async def buscar_produtos_ml(query: str, user_id: int = None, limit: int = 20):
    """
    üö® BUSCA MERCADO LIVRE - API P√öBLICA SEM HEADERS
    
    API p√∫blica do ML rejeita qualquer header extra.
    Usar apenas requests.get(url) puro para busca p√∫blica.
    """
    print(f"üîç ML SEARCH: query='{query}', user_id={user_id}")
    
    # URL para busca p√∫blica (sem autentica√ß√£o)
    search_url = f"{ML_API_URL}/sites/MLB/search"
    params = {
        "q": query,
        "limit": limit,
        "site_id": "MLB"
    }
    
    try:
        # Tentar busca autenticada primeiro (se tiver token v√°lido)
        if user_id:
            token = MLTokenManager.get_token(user_id)
            if token:
                print(f"üîê Busca autenticada para user {user_id}")
                async with httpx.AsyncClient() as client:
                    headers = {"Authorization": f"Bearer {token}"}
                    resp = await client.get(search_url, headers=headers, params=params, timeout=10.0)
                    if resp.status_code == 200:
                        print(f"‚úÖ Busca autenticada bem-sucedida")
                        return resp.json()
                    print(f"‚ö†Ô∏è Busca autenticada falhou ({resp.status_code}), tentando busca p√∫blica")
        
        # Busca p√∫blica - SEM HEADERS, SEM PAR√ÇMETROS EXTRAS
        print(f"üåê Busca p√∫blica - requests puro sem headers")
        import requests
        
        # Construir URL completa (a API p√∫blica prefere URL completa vs params)
        public_url = f"{ML_API_URL}/sites/MLB/search?q={query}&limit={limit}"
        print(f"üì° URL: {public_url}")
        
        # üö® CR√çTICO: ZERO headers, ZERO configura√ß√µes extras
        resp = requests.get(public_url)
        
        print(f"üìä Status p√∫blico: {resp.status_code}")
        
        if resp.status_code == 200:
            print(f"‚úÖ Busca p√∫blica bem-sucedida")
            return resp.json()
        else:
            print(f"‚ùå Busca p√∫blica falhou: {resp.status_code} - {resp.text[:200]}")
            return None
            
    except Exception as e:
        print(f"‚ùå Erro geral na busca ML: {str(e)}")
        return None

async def buscar_avaliacoes_ml(ml_id: str, user_id: int = None):
    """
    Busca avalia√ß√µes do produto conforme documenta√ß√£o oficial ML
    Endpoint de reviews √© p√∫blico mas pode usar autentica√ß√£o para mais dados
    """
    url = f"{ML_API_URL}/reviews/item/{ml_id}"
    
    print(f"üîç Buscando avalia√ß√µes de {ml_id}")
    
    if user_id:
        # Tentar busca autenticada para mais detalhes
        token = MLTokenManager.get_token(user_id)
        if token:
            try:
                print(f"üîê Tentando busca autenticada de avalia√ß√µes")
                async with httpx.AsyncClient() as client:
                    headers = {"Authorization": f"Bearer {token}"}
                    resp = await client.get(url, headers=headers, timeout=10.0)
                    if resp.status_code == 200:
                        data = resp.json()
                        print(f"‚úÖ Avalia√ß√µes autenticadas obtidas")
                        return data.get("reviews", [])
                    print(f"‚ö†Ô∏è Busca autenticada de avalia√ß√µes falhou: {resp.status_code}")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro na busca autenticada de avalia√ß√µes: {e}")
    
    # Busca p√∫blica de avalia√ß√µes
    print(f"üåê Fazendo busca p√∫blica de avalia√ß√µes")
    try:
        import requests
        # Endpoint de reviews pode ser p√∫blico
        resp = requests.get(url)
        print(f"üìä Status avalia√ß√µes p√∫blicas: {resp.status_code}")
        
        if resp.status_code == 200:
            data = resp.json()
            print(f"‚úÖ Avalia√ß√µes p√∫blicas obtidas")
            return data.get("reviews", [])
        else:
            print(f"‚ùå Busca p√∫blica de avalia√ß√µes falhou: {resp.status_code}")
            return []
    except Exception as e:
        print(f"‚ùå Erro na busca p√∫blica de avalia√ß√µes: {e}")
        return []